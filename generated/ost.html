<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2024-04-20" />
  <title>Overload Set Types</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.csl-block{margin-left: 1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
text-align: justify;
}
@media screen and (max-width: 30em) {
body {
margin: 1.5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Overload Set Types</h1>
<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>DxxxxR0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2024-04-20</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWGI<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Bengt Gustafsson<br>&lt;<a href="mailto:bengt.gustafsson@beamways.com" class="email">bengt.gustafsson@beamways.com</a>&gt;<br>
    </td>
  </tr>
</table>
</header>
<div style="clear:both">
<h1 data-number="1" id="abstract"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>This proposal defines a type for each overload set of more than one
function. Unique such <em>overload-set-types</em> are created each time
a placeholder type is <em>deduced</em> from an overloaded function name.
These types have no runtime state, in contrast with function pointers.
This proposal does not specify any new keywords or operators, it just
expands what placeholder types can be deduced from.</p>
<p>An object of <em>overload-set-type</em> can be called like the
function overloads it represents, and overload resolution works exactly
the same as if the overloaded function is called directly at the
<em>point of deduction</em>. This includes overloads found by ADL and
defaulted function parameters. Additionally, an object of
<em>overload-set-type</em> can be implicitly converted to the function
pointer type of any of the overloaded functions it represents.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> callWithFloat<span class="op">(</span><span class="kw">auto</span> f<span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="op">(*</span>dfp<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> f<span class="op">;</span>   <span class="co">// The appropriate overload of f is selected, error if none.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f<span class="op">(</span><span class="fl">3.14</span><span class="bu">f</span><span class="op">);</span>             <span class="co">// If f is overloaded overload resolution occurs here.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">// As std::sin is overloaded the type of f above is an overload set type for std::sin at this </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">// point of translation</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x <span class="op">=</span> callWithFloat<span class="op">(</span><span class="bu">std::</span>sin<span class="op">);</span></span></code></pre></div>
<p>As this feature only relies on compile time overload resolution it
works also for constructors, destructors, operators and member
functions. For member functions and destructors the member function
pointer call syntax must be used, while for constructors and operators
regular function call syntax is used.</p>
<h1 data-number="2" id="motivation"><span class="header-section-number">2</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>Today you can’t use functions that are overloaded when the type is
deduced, only functions that are not overloaded. This is annoying for
instance with algorithms such as <code class="sourceCode cpp">std<span class="op">::</span>transform</code>
which often require wrapping a function in a lambda just because it is
overloaded. With this proposal any function, overloaded or not, can be
used in such scenarios.</p>
<h2 data-number="2.1" id="natural-predicate-syntax"><span class="header-section-number">2.1</span> Natural predicate syntax<a href="#natural-predicate-syntax" class="self-link"></a></h2>
<p>Here are some examples involving <code class="sourceCode cpp">std<span class="op">::</span>transform</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> in <span class="op">=</span> getInputValues<span class="op">();</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> out<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>transform<span class="op">(</span>in<span class="op">.</span>begin<span class="op">(),</span> in<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>out<span class="op">),</span> <span class="er">@</span>__std<span class="op">::</span>sin__<span class="er">@</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Or with ranges</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> out_r <span class="op">=</span> <span class="bu">std::</span>views<span class="bu">::</span>all<span class="op">(</span>in<span class="op">)</span> <span class="op">|</span> </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>             <span class="bu">std::</span>views<span class="bu">::</span>transform<span class="op">(</span><span class="er">@</span>__std<span class="op">::</span>sin__<span class="er">@</span><span class="op">)</span> <span class="op">|</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>             <span class="bu">std::</span>ranges<span class="bu">::</span>to<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&gt;();</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Also works with operators</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> neg_r <span class="op">=</span> <span class="bu">std::</span>views<span class="bu">::</span>all<span class="op">(</span>out_r<span class="op">)</span> <span class="op">|</span> </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>             <span class="bu">std::</span>views<span class="bu">::</span>transform<span class="op">(</span><span class="er">@</span>__operator<span class="op">-</span>__<span class="er">@</span><span class="op">)</span> <span class="op">|</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>             <span class="bu">std::</span>ranges<span class="bu">::</span>to<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&gt;();</span></span></code></pre></div>
<h2 data-number="2.2" id="even-more-perfect-forwarding"><span class="header-section-number">2.2</span> Even more perfect forwarding<a href="#even-more-perfect-forwarding" class="self-link"></a></h2>
<p>Another problem that this proposal solves is that function pointers
don’t work with <em>perfect forwarding</em> when passing an overloaded
function. Here is an example involving <code class="sourceCode cpp">std<span class="op">::</span>make_unique</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyClass <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    MyClass<span class="op">(</span><span class="dt">float</span> <span class="op">(*</span>fp<span class="op">)(</span><span class="dt">float</span><span class="op">));</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>MyClass<span class="op">&gt;(</span><span class="er">@</span>__std<span class="op">::</span>sin__<span class="er">@</span><span class="op">);</span>       <span class="co">// Works with this proposal!</span></span></code></pre></div>
<p>Today <code class="sourceCode cpp">make_unique</code> can’t be called
with
<code class="sourceCode cpp">std<span class="op">::</span>sin</code> as
argument although <code class="sourceCode cpp">MyClass</code> can be
constructed with it. This is as the <code class="sourceCode cpp"><span class="kw">auto</span><span class="op">&amp;&amp;</span></code>
placeholder type of make_unique can’t be deduced from a an overloaded
function name.</p>
<h2 data-number="2.3" id="helping-contract-condition-testing"><span class="header-section-number">2.3</span> Helping contract condition
testing<a href="#helping-contract-condition-testing" class="self-link"></a></h2>
<p>This proposal also solves the issue encountered in <span class="citation" data-cites="P3183R0">[<a href="https://wg21.link/p3183r0" role="doc-biblioref">P3183R0</a>]</span> where
<code class="sourceCode cpp">declcall</code> of <span class="citation" data-cites="P2825R2">[<a href="https://wg21.link/p2825r2" role="doc-biblioref">P2825R2</a>]</span> and macros was employed to
allow overloaded functions to be tested by its
<code class="sourceCode cpp">check_preconditions</code> and
<code class="sourceCode cpp">check_postconditions</code> functions. This
proposal also allows operator, constructor and destructor contracts to
be tested without further compiler magic.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// P3183R0</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHECK_PRECONDITION_VIOLATION</span><span class="op">(</span>F<span class="op">,</span><span class="pp"> </span><span class="op">...)</span><span class="pp"> </span><span class="er">\</span><span class="pp">        </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;</span><span class="fu">__builtin_calltarget</span><span class="op">(</span>F<span class="op">(</span>__VA_ARGS__<span class="op">))&gt;(</span>__VA_ARGS__<span class="op">))</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>CHECK_PRECONDITION_VIOLATION<span class="op">(</span>myOverloadedFunction<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">// With this proposal:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;</span>myOverloadedFunction<span class="op">&gt;(</span><span class="dv">1</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">));</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">// And also</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;&amp;</span>MyClass<span class="op">::</span>func<span class="op">&gt;(</span>MyClass<span class="op">{},</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">));</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;</span><span class="kw">operator</span><span class="op">+&gt;(</span>MyClass<span class="op">{},</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;</span>MyClass<span class="op">::</span>MyClass<span class="op">&gt;(</span><span class="dv">1</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">));</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;</span>MyClass<span class="op">::~</span>MyClass<span class="op">&gt;());</span></span></code></pre></div>
<h1 data-number="3" id="proposal"><span class="header-section-number">3</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>This proposal allow placeholder types to be deduced from function
names for overloaded functions. The proposal has no effect for functions
that are not overloaded, these deduce the placeholder type to the
function’s function reference type as today, and sets the value to the
function pointer.</p>
<p>The idea is that all aspects of the original function overload set is
preserved when applying the function call operator to an object of
<em>overload-set-type</em>.</p>
<p>Each time a placeholder type is deduced from the name of an
overloaded function a unique conceptual <em>overload-set-type</em> is
created. This type has a generic call operator calling the function and
a conversion operator to each function pointer type. The
<em>overload-set-type</em> as such is regular and all instances compare
equal. All overload resolution is done at compile time, only depending
on the <em>overload-set-type</em>. In contrast with a function pointer
there is no runtime data to carry around, so the actual function calls
compiled into the object code doesn’t do runtime dispatch (except
virtual dispatch).</p>
<p>Here is an example assuming that
<code class="sourceCode cpp">std<span class="op">::</span>sin</code> has
two overloads:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Exposition only</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> __std_sin_overload_set_type_1 <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">&amp;&amp;...</span> as<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="er">@</span>__std<span class="op">::</span>sin__<span class="er">@</span><span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>as<span class="op">)&gt;(</span>as<span class="op">)...);</span> </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="er">@</span>_implicit_<span class="er">@</span> <span class="kw">operator</span> <span class="dt">float</span> <span class="op">(&amp;)(</span><span class="dt">float</span><span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="er">@</span>__std<span class="op">::</span>sin__<span class="er">@</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="er">@</span>_implicit_<span class="er">@</span> <span class="kw">operator</span> <span class="dt">double</span> <span class="op">(&amp;)(</span><span class="dt">double</span><span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="er">@</span>__std<span class="op">::</span>sin__<span class="er">@</span><span class="op">;</span> <span class="op">}</span>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Note the trailing <code class="sourceCode cpp">_1</code> on the
struct’s name. This is to indicate that each time a placeholder type is
deduced from
<code class="sourceCode cpp">std<span class="op">::</span>sin</code> a
new <code class="sourceCode cpp">overload<span class="op">-</span>set<span class="op">-</span>type</code>
is created. The intent is for this mechanism to work exactly as for
lambdas today, where each lambda has unique type even if its definition
is the same. The rules are also the same as for lambdas when defined in
header files consumed by multiple TUs.</p>
<p>The analogy with lambdas goes only thus far, a compiler is required
to elide the generic call operator and function pointer cast operators.
In reality the <em>overload-set-type</em> is just a way to express that
the compiler remembers the contents of the overload set at the point of
deduction. This is why the cast operators are marked <em>implicit</em>
in the example, they don’t actually count as user defined conversions in
overload resolution.</p>
<p>Although the exact type of each unique <em>overload-set</em> is
unnamed (just like a lambda) it can be retrieved using
<code class="sourceCode cpp"><span class="kw">decltype</span></code>
(just like a lambda). As there are no data members an
<em>overload-set</em> is always default constructible, copyable and
assignable, but only within each <em>overload-set-type</em>, which means
that you can’t change the contents of the overload set by
assignment.</p>
<p>Here are some examples of code valid with this proposal:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compose<span class="op">(</span><span class="kw">auto</span> F<span class="op">,</span> <span class="kw">auto</span> G<span class="op">,</span> <span class="kw">auto</span> value<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> F<span class="op">(</span>G<span class="op">(</span>value<span class="op">));</span> <span class="op">}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> one <span class="op">=</span> compose<span class="op">(</span><span class="bu">std::</span>tan<span class="op">,</span> <span class="bu">std::</span>atan<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s <span class="op">=</span> <span class="bu">std::</span>sin<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> SinOverloads <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>s<span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>callWihtT<span class="op">(</span>SinOverloads<span class="op">(),</span> <span class="fl">3.15</span><span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> cc<span class="op">(</span><span class="dt">float</span> <span class="op">(*</span>f<span class="op">)(</span><span class="dt">float</span><span class="op">));</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>cc<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sptr <span class="op">=</span> <span class="er">@</span>_declcall_<span class="er">@</span><span class="op">(</span>s<span class="op">(</span><span class="fl">2.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>cc<span class="op">(</span>sptr<span class="op">);</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sptr2 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">float</span><span class="op">(*)(</span><span class="dt">float</span><span class="op">)&gt;(</span>s<span class="op">);</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>cc<span class="op">(</span>sptr2<span class="op">);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x <span class="op">=</span> s<span class="op">(</span><span class="fl">3.14</span><span class="op">);</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">(</span><span class="bu">std::</span>sin<span class="op">);</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">{</span><span class="bu">std::</span>sin<span class="op">};</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>sin<span class="op">);</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">auto</span> F<span class="op">&gt;</span> <span class="dt">void</span> myFun<span class="op">()</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="kw">requires</span> <span class="op">{</span> F<span class="op">(</span><span class="fl">1.2</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">);</span> <span class="op">}</span> </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    F<span class="op">(</span><span class="fl">2.3</span><span class="op">,</span> <span class="st">&quot;Bye&quot;</span><span class="op">);</span> </span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 data-number="3.1" id="defaulted-parameters"><span class="header-section-number">3.1</span> Defaulted parameters<a href="#defaulted-parameters" class="self-link"></a></h2>
<p>As the intent with this proposal is to be able to call an object of
overload set type <em>exactly</em> as the function the type was deduced
from defaulted parameters are considered in the overload resolution
process. By the same convention, when converting an object of overload
set type to a function pointer defaulted parameters are <em>not</em>
considered.</p>
<h2 data-number="3.2" id="template-functions"><span class="header-section-number">3.2</span> Template functions<a href="#template-functions" class="self-link"></a></h2>
<p>If the overload set contains template functions these are included in
the <em>overload-set-type</em> and selected by overload resolution as
usual. Specializations of template functions declared after the point of
deduction are not considered but if a matching template instantiation is
selected the program is ill-formed just like when any template is
explicitly specialized after the compiler has already instantiated the
base template. Just like with lambdas this can happen if an explicit
specialization is declared between the point of deduction and the point
of call, not only if the explicit specialization is declared after the
point of call.</p>
<h2 data-number="3.3" id="specifiers-such-as-noexcept-and-constexpr"><span class="header-section-number">3.3</span> Specifiers such as noexcept and
constexpr<a href="#specifiers-such-as-noexcept-and-constexpr" class="self-link"></a></h2>
<p>In keeping with the general idea all specifiers on functions in the
overload set are carried over to the <em>overload-set-type</em> and work
the same as if the function name was used directly.</p>
<h2 data-number="3.4" id="free-functions"><span class="header-section-number">3.4</span> Free functions<a href="#free-functions" class="self-link"></a></h2>
<p>Overload sets for free functions include overloads found by ADL which
means that an <em>overload-set-type</em> is even more magic and requires
the compiler to remember the entire state of the symbol tables at the
point of deduction. This is the same rule as for generic lambdas
containing function calls.</p>
<p>The function call operatore can be applied to an object of
<em>overload-set-type</em> just as if the original function was called.
Overload resolutions also happens when a <em>overload-set</em>-type
object is used inside a <code class="sourceCode cpp">declcall</code>
construct of <span class="citation" data-cites="P2825R2">[<a href="https://wg21.link/p2825r2" role="doc-biblioref">P2825R2</a>]</span> while
<code class="sourceCode cpp"><span class="kw">static_cast</span></code>
and binding to a function pointer or reference just selects one overload
with matching signature if one exists.</p>
<h2 data-number="3.5" id="member-functions"><span class="header-section-number">3.5</span> Member functions<a href="#member-functions" class="self-link"></a></h2>
<p>The proposed feature works also when a placeholder type is deduced
from an overloaded member function name, except that to call a member
function the <code class="sourceCode cpp"><span class="op">(</span>ref<span class="op">.*</span>f<span class="op">)(</span>args<span class="op">...)</span></code>
or <code class="sourceCode cpp"><span class="op">(</span>ptr<span class="op">-&gt;*</span>f<span class="op">)(</span>args<span class="op">...)</span></code>
syntax must be used, just as if the member function was not overloaded.
Overload resolution works exactly as for the overloaded member function
the object of overload set type represents. Likewise, an object of
overload set type can be implicitly converted to the member function
pointer type of any of the member function overloads it represents.</p>
<p>When an <em>overload-set-type</em> is deduced from a <em>member</em>
function name it can always be used with an object reference, even if it
contains
<code class="sourceCode cpp"><span class="kw">static</span></code>
overloads. This ensures that overload resolution works the same as if
the member function was called directly.</p>
<p>When a virtual function is selected by overload resolution the call
is dispatched virtually even though the member function pointer call
syntax is used, which today just calls the member function provided in
the member function pointer.</p>
<p>For overload sets that contain static member functions it is also
possible to use regular function call syntax, and just as when using the
<code class="sourceCode cpp">Class<span class="op">::</span>function</code>
syntax this fails if a non-static function is selected by overload
resolution.</p>
<p>Further, converting the object of overload set type to a member
function pointer type works the same as when converting a member
function name directly, but if the function pointer type is for a free
function there must be a matching <em>static</em> member function or
member function with explicit object reference in the overload set.</p>
<h3 data-number="3.5.1" id="allowing-stdinvoke-with-all-overload-set-types"><span class="header-section-number">3.5.1</span> Allowing std::invoke with all
<em>overload-set-types</em><a href="#allowing-stdinvoke-with-all-overload-set-types" class="self-link"></a></h3>
<p><code class="sourceCode cpp">std<span class="op">::</span>invoke</code>
and similar functions should work as expected for
<em>overload-set-types</em> created from member function overload sets
as well as for free function overload sets if the invoke overload
selection is made based on constraints rather than on matching function
pointer or member function pointer signatures. As constraints are
relatively new it is likely that many
<code class="sourceCode cpp">std<span class="op">::</span>invoke</code>
implementations will have to be rewritten to allow calling with an
object of <code class="sourceCode cpp">overload<span class="op">-</span>set<span class="op">-</span>type</code>
as the first argument. There should be no ABI breakage caused by this
type of change as the selected overload of any
<code class="sourceCode cpp">std<span class="op">::</span>invoke</code>
call that can be made today has the same signature.</p>
<h2 data-number="3.6" id="constructors"><span class="header-section-number">3.6</span> Constructors<a href="#constructors" class="self-link"></a></h2>
<p>An <em>overload-set-type</em> can be created by deducing a
placeholder type from a constructor name in the form <code class="sourceCode cpp"><span class="op">&amp;</span>Class<span class="op">::</span>Class</code>.
Objects of type <code class="sourceCode cpp">Class</code> can
subsequently be created by applying the call operator to the an object
of this overload set type. As constructors don’t have function pointer
types there is no possibility to convert an <em>overload-set-type</em>
deduced from a constructor to a “constructor pointer”.</p>
<p>As non-overloaded constructors don’t have function pointer types even
non-overloaded constructors deduce to overload set types.</p>
<h2 data-number="3.7" id="destructors"><span class="header-section-number">3.7</span> Destructors<a href="#destructors" class="self-link"></a></h2>
<p>Even though destructors are not overloadable
<em>overload-set-types</em> can be deduced from destructor names in the
form <code class="sourceCode cpp"><span class="op">&amp;</span>Class<span class="op">::~</span>Class</code>
as there is no corresponding function pointer type. Objects of the
deduced <code class="sourceCode cpp">overload<span class="op">-</span>set<span class="op">-</span>type</code>
contain one overload which can be called just like a parameterless
member function pointer and which can’t be converted to a “destructor
pointer” as there is no such thing.</p>
<h2 data-number="3.8" id="operators"><span class="header-section-number">3.8</span> Operators<a href="#operators" class="self-link"></a></h2>
<p>An <em>overload-set-type</em> can be created by deducing a
placeholder type from an operator in the form <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>
for each <em>overloadable-operator</em> @. When an
<em>overload-set-type</em> is deduced from an overloaded operator it
follows the rules of overload resolution for the operator, which means
that both member function and free function operators are considered,
except when explicitly scoping the operator to a class or namespace.
This behavior is consistent with using the
<em>overloadable-operator</em> inside a lambda. This proposal does not
support operator-&gt;, operator-&gt;* which can’t be overloaded or
overloaded conversion operators which can’t be spelled in the grammar.
Whether
<code class="sourceCode cpp"><span class="kw">operator</span>,</code>
<code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code>,
<code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code>,
<code class="sourceCode cpp"><span class="kw">operator</span><span class="st">&quot;&quot;</span></code>
and <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">co_await</span></code>
can and should be supported is still not properly investigated.</p>
<p>An object of an <em>overload-set-type</em> deduced from an operator
can be called with one or two arguments as applicable for the operator.
Overload sets for operators that have both unary and binary forms
contain both unary and binary overloads found at the point of deduction.
When a placeholder type is deduced from an unqualified operator name all
available overloads, including those for fundamental types and those
found via ADL are included in the overload set. This ensures that
calling an object of such an <em>overload-set-type</em> performs
overload resolution in exactly the same was as if the operator had been
called using the form such as
<code class="sourceCode cpp">lhs <span class="op">@</span> rhs</code> or
<code class="sourceCode cpp"><span class="op">@</span> arg</code>. Note
that this is <em>not</em> the same as the call <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@(</span>lhs, rhs<span class="op">)</span></code>
or <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@(</span>arg<span class="op">)</span></code>
which only considers operators declared as free functions.</p>
<p>The prefix and postfix versions of
<code class="sourceCode cpp"><span class="op">++</span></code> and
<code class="sourceCode cpp"><span class="op">--</span></code> are
treated as they usually are; the postfix version requires an extra
argument convertible to int.</p>
<p>The inconsistency introduced above means that there is no way to
deduce an overload set type that contains only the free function
operator overloads as the syntax <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>
is already used. This drawback seems acceptable as it is much more
useful to be able to denote an entire overload set regardless of whether
individual operators are declared as free functions (including friends)
or member functions. A possible alternative is discussed in the next
chapter.</p>
<p>If an <em>overload-set-type</em> is deduced from a qualified operator
name such as <code class="sourceCode cpp">MyClass<span class="op">::</span><span class="kw">operator</span><span class="op">@</span></code>
only the operator overloads declared in the class (with bases) are
included. Note that as <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">[]</span></code>
and <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">()</span></code>
can only be declared as member functions they can only be deduced from a
qualified operator name , never from just the operator name. <em>This
may be the wrong decision, it doesn’t seem that these actually differ
from other operators where the complete set of overloads declared as
members must be conveyed to the overload-set-type. However, intuitively
it seems strange to pass operator[] to a function to let it index
anything.</em></p>
<h1 data-number="4" id="possible-extensions-and-alternatives"><span class="header-section-number">4</span> Possible extensions and
alternatives<a href="#possible-extensions-and-alternatives" class="self-link"></a></h1>
<h3 data-number="4.0.1" id="allowing-member-function-references"><span class="header-section-number">4.0.1</span> Allowing member function
references<a href="#allowing-member-function-references" class="self-link"></a></h3>
<p>Today there is no such thing as a member function reference. Thus we
for consistency require the qualified member function name to be
explicitly converted to a member function pointer using a prefix
<code class="sourceCode cpp"><span class="op">&amp;</span></code>
operator. This is what this proposal suggests.</p>
<p>Introducing member references could be a good idea, but it is another
proposal. This has its own complications as the rules for automatic
conversion from free functions to function references and function
pointers are somewhat contrived due to historical reasons, and decisions
have to be made as to if member pointers and references should work the
same or deviate somehow.</p>
<h3 data-number="4.0.2" id="calling-non-static-member-functions-using-regular-function-call-syntax."><span class="header-section-number">4.0.2</span> Calling non-static member
functions using regular function call syntax.<a href="#calling-non-static-member-functions-using-regular-function-call-syntax." class="self-link"></a></h3>
<p>It would be possible to allow using regular function call syntax on
objects with <em>overload-set-type</em> even if the type is deduced from
an overloaded member function. Providing the implicit object reference
as the first argument would be required at each call site, just as for
<code class="sourceCode cpp">std<span class="op">::</span>invoke</code>.
If the overload set contains static member functions these would then be
represented by two synthesized overloads in the
<em>overload-set-type</em> which causes a risk for ambiguity not present
when calling the static member function directly.</p>
<p>The advantage of this idea is that the user of the
<em>overload-set-type</em> object does not have to know if the <code class="sourceCode cpp">overload<span class="op">-</span>set<span class="op">-</span>type</code>
was deduced from a free function or a member function. This is a very
limited form of <em>unified function call syntax</em> and does not solve
the poster child use case for UFCS where for instance
<code class="sourceCode cpp">begin</code> and
<code class="sourceCode cpp">end</code> can either be free functions
taking an object or a member of that object’s type.</p>
<p>To make this functionality useful it would have to be made possible
to call a <em>member function pointer</em> as a regular function,
providing the implicit object reference explicitly. Otherwise we get
functionality that <em>only</em> works if the member function is
overloaded. On the flip side we today have a situation where static,
explicit object reference and non-static member functions work
differently in this respect, which such a feature would unify.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyClass <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span> g<span class="op">();</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h<span class="op">(</span><span class="kw">this</span> MyClass<span class="op">&amp;</span> o<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> fp <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span>f<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> gp <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span>g<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> hp <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span>h<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>MyClass o<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>o<span class="op">.*</span>fp<span class="op">)();</span>      <span class="co">// Ok</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>o<span class="op">.*</span>gp<span class="op">)();</span>      <span class="co">// Error</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>o<span class="op">.*</span>hp<span class="op">)();</span>      <span class="co">// Error</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>fp<span class="op">(</span>o<span class="op">);</span>          <span class="co">// Error</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>gp<span class="op">(</span>o<span class="op">);</span>          <span class="co">// Error</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>hp<span class="op">(</span>o<span class="op">);</span>          <span class="co">// ok</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>gp<span class="op">();</span>           <span class="co">// ok</span></span></code></pre></div>
<p>For consistency with the overloaded case as defined above all
possibilities for calling must be allowed, where the calls to g just
ignore the object reference.</p>
<p>As extending rules for member function pointers in this way is a
prerequisite for extending overload-set-type objects with free function
callability this is not included in this proposal. Instead this would be
an addition to a UFCS proposal to make sure it works consistently
between named functions and <em>overload-set-type</em> objects.</p>
<h3 data-number="4.0.3" id="deduction-from-operator-tokens"><span class="header-section-number">4.0.3</span> Deduction from operator
tokens<a href="#deduction-from-operator-tokens" class="self-link"></a></h3>
<p>To avoid above mentioned inconsistency for operators, where a direct
call of <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>
does not correspond to the function call operator applied to an
<em>overload-set-type</em> deduced from <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>
it would be nice to be able to deduce an placeholder type from the
<em>operator-token</em> itself. Then we could write code like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> in <span class="op">=</span> getInputValues<span class="op">();</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> out<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>transform<span class="op">(</span>in<span class="op">.</span>begin<span class="op">(),</span> in<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>out<span class="op">),</span> <span class="er">@</span>__<span class="op">-</span>__<span class="er">@</span><span class="op">);</span> <span class="co">// Invert values</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> plusses <span class="op">=</span> <span class="er">@</span>__<span class="op">+</span>__<span class="er">@</span><span class="op">;</span>             <span class="co">// All overloads of +</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> free_plusses <span class="op">=</span> <span class="kw">operator</span><span class="op">+;</span>      <span class="co">// Only free function overloads of +</span></span></code></pre></div>
<p>This functionality is the same for operators that can be defined both
as free functions and member functions and for those that can only be
defined as member functions.</p>
<p>To make this work a new production in the
<em>assignment-expression</em> rule can be added. As this production
only contains an <em>operator-token</em> there is no risk of parsing
ambiguity. The only strain on the compiler is that if an expression
starts with an <em>operator-token</em> the next token must be checked to
see if is a comma, semicolon, right parenthesis, bracket or brace. If so
select the <em>operator-token</em> only case whereas for any other token
parsing proceeds as today, eventually consuming the
<em>operator-token</em> in <em>unary-expression</em>.</p>
<blockquote>
<div class="line-block"><em>assignment-expression:</em><br />
    <em>conditional-expression</em><br />
    <em>logical-or-expression</em> <em>assignment-operator</em>
<em>initializer-clause</em><br />
    <em>throw-expression</em><br />
    <span class="add" style="color: #006e28"><ins><em>operator-token</em></ins></span></div>
</blockquote>
<p>It would be possible to forbid expressions consisting of only an
<em>operator-token</em> when not used to deduce a placeholder type, but
this seems complicated wording wise, and compilers usually have warnings
like <em>statement has no effect</em>, in these cases which may be
sufficient to filter out the case where a stray <em>operator-token</em>
is mistakenly typed.</p>
<p>The reason for placing this production in the assignment-expression
rule is to be able to use <em>overloaded-operators</em> as function
arguments. If it was placed in the <em>expression</em> rule any usage as
a function argument would have to be enclosed in parentheses. A third
option is to <em>mandate</em> surrounding parentheses at all use by
instead introducing a new production in <em>primary-expression</em>
adding a third type of parenetheses along with fold expressions and
nested expressions. This approach may be safer and the extra parenthesis
highlights that something special is going on.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> in <span class="op">=</span> getInputValues<span class="op">();</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> out<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>transform<span class="op">(</span>in<span class="op">.</span>begin<span class="op">(),</span> in<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>out<span class="op">),</span> <span class="er">@</span>__<span class="op">(-)</span>__<span class="er">@</span><span class="op">);</span> <span class="co">// Invert values</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> plusses <span class="op">=</span> <span class="er">@</span>__<span class="op">(+)</span>__<span class="er">@</span><span class="op">;</span>             <span class="co">// All overloads of +</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> free_plusses <span class="op">=</span> <span class="kw">operator</span><span class="op">+;</span>      <span class="co">// Only free function overloads of +</span></span></code></pre></div>
<p>An expression of the form
<code class="sourceCode cpp"><span class="op">(@)</span></code> will
evaluate to an instance of an <em>overload-set-type</em> regardless of
whether a placeholder type is deduced from it. This seems necessary as
there is no other type this expression could have. This means that by
coincidence it is now possible to write <code class="sourceCode cpp"><span class="op">(@)(</span>lhs, rhs<span class="op">)</span></code>
or <code class="sourceCode cpp"><span class="op">(@)(</span>arg<span class="op">)</span></code>
due to how the grammar works.</p>
<p>An advantage of this formulation is that we can still never write two
consecutive commas, whereas with the production in
<em>assignment-expression</em> we can write <code class="sourceCode cpp"><span class="kw">auto</span> x <span class="op">=</span> ,,<span class="dv">1</span>;</code>
as the first comma is an <em>assignment-expression</em> but then the
<em>expression</em> production including the comma operator is employed
so the second comma causes the first comma to be ignored and x is
initialized to the integer 1.</p>
<p><em>NOTE: As this changes the meaning of deducing a placeholder type
from <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>
this addition must be included from the beginning and can not be added
later.</em> <em>For this reason the author would prefer for this option
to be added included in the proposal.</em></p>
<h3 data-number="4.0.4" id="supporting-overloaded-conversion-functions"><span class="header-section-number">4.0.4</span> Supporting overloaded
conversion functions<a href="#supporting-overloaded-conversion-functions" class="self-link"></a></h3>
<p>It may be possible to create an <em>overload-set-type</em> from all
the conversion operators of a class, but this would require some
specific new syntax such as <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">typename</span></code>
to be able to denote this overload set. Overload set types of this
variety would be very special just as overloaded conversion operators
themselves, as the overload selection happens due to the <em>required
return type</em> rather than the argument types (which is always the
object itself). This type of backwards overload resolution is already
implemented in compilers so it doesn’t seem overly complicated to allow
this too, except for the special keyword parsing.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyClass <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="dt">double</span><span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> conv <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span><span class="kw">operator</span> <span class="er">@</span><span class="op">**</span><span class="kw">typename</span><span class="op">**</span><span class="er">@</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>MyClass c<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="op">(</span>c<span class="op">.*</span>conv<span class="op">)();</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> a <span class="op">=</span> <span class="op">(</span>c<span class="op">.*</span>conv<span class="op">)();</span></span></code></pre></div>
<p>This feature would not be needed for <span class="citation" data-cites="P3183R0">[<a href="https://wg21.link/p3183r0" role="doc-biblioref">P3183R0</a>]</span> to test contracts on conversion
functions as each overload has its own name which enables for
instance:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>check_preconditions<span class="op">&lt;</span>MyClass<span class="op">::</span><span class="kw">operator</span> <span class="dt">int</span><span class="op">&gt;(</span>myObject<span class="op">));</span></span></code></pre></div>
<p>In fact it seems rather unnecessary to support overload sets of
conversion operators given that it requires a syntactical extension and
seems more risky when it comes to implementation effort depending on
compiler internals.</p>
<p>The use of an overload set of conversion functions could be to force
a value to be converted to some type, for instance using transform. But
in this use case you usually don’t know if the conversion is done via a
conversion function or a converting constructor in the resulting type.
To let the compiler select how to convert the value you can already use
the destination type as a predicate and the compiler will select to
either construct the destination type from the source or employ a
conversion operator in the source. (CHECK THIS), probably you have to
provide a lambda doing static_cast for such selection to take place as
in regular code:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>C1<span class="op">&gt;</span> in <span class="op">=</span> getInputValues<span class="op">();</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>C2<span class="op">&gt;</span> out<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>transform<span class="op">(</span>in<span class="op">.</span>begin<span class="op">(),</span> in<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>out<span class="op">),</span> C2<span class="op">);</span> <span class="co">// does not work, obviously.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>transform<span class="op">(</span>in<span class="op">.</span>begin<span class="op">(),</span> in<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>out<span class="op">),</span> <span class="op">[](</span>C1 x<span class="op">)-&gt;</span>C2 <span class="op">{</span> <span class="cf">return</span> x<span class="op">;</span> <span class="op">});</span> <span class="co">// Works</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>transform<span class="op">(</span>in<span class="op">.</span>begin<span class="op">(),</span> in<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>out<span class="op">),</span> <span class="op">&amp;</span>C2<span class="op">::</span>C2<span class="op">);</span>  <span class="co">// Works only for C2 ctor.</span></span></code></pre></div>
<p>This proposal does not offer a good solution to this and the old
lambda based solution must still be used.</p>
<h2 data-number="4.1" id="supporting-opt-in-ufcs"><span class="header-section-number">4.1</span> Supporting opt-in UFCS<a href="#supporting-opt-in-ufcs" class="self-link"></a></h2>
<p>With some additional building blocks this proposal could support an
opt-in version of unified function call syntax. Such functionality could
be accomplished by defining a way to merge two overload sets and some
way to denote an empty overload set.</p>
<p>For instance if you want to call whichever is available of
begin(object) and object.begin() you can do that today, but it requires
name specific coding using SFINAE but this method is very verbose, which
can be mitigated by using a macro. For the example name <em>begin</em>
the code could look like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">auto</span> call_begin<span class="op">(</span>T<span class="op">&amp;</span> object<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="kw">requires</span> <span class="op">{</span> object<span class="op">.</span>begin<span class="op">();</span> <span class="op">})</span>  <span class="co">// This impl. prefers members if both exist.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> object<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> begin<span class="op">(</span>object<span class="op">);</span>       <span class="co">// ADL in effect.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>What we would need help from this proposal for is to not have to code
this for each name, but to be able to send the function name in to the
function as an extra parameter:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> F<span class="op">&gt;</span> <span class="kw">auto</span> call_named<span class="op">(</span>F f<span class="op">,</span> T<span class="op">&amp;</span> object<span class="op">);</span></span></code></pre></div>
<p>However, as written, this only works for operators due to the
inconsistent definition of the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>
name or via the extension mentioned above. What we want here is a way to
do the same for any function name. If we can just figure that one out it
seems that opt-in UFCS is within reach. Note that with a syntax to
represent a function name’s free function and member function overloads
we would do overload resolution within the set of both free and member
functions in the same way it is done for operators today.</p>
<p>This suggests changing the syntax suggested for
<em>overloadable-operators</em> indicated above to something that can be
used for any function name. This does not work for the <code class="sourceCode cpp"><span class="op">(</span>function<span class="op">)</span></code>
syntax that works for operators as this already has meaning (the same
meaning as without the parentheses). Instead we could define a new
prefix operator out of the remaining operator tokens that can’t be used
in a prefix position. Candidates include
<code class="sourceCode cpp"><span class="op">|</span></code> and
<code class="sourceCode cpp"><span class="op">%</span></code> and there
is also the newly added characters where the backtick could be used to
enclose a function name like so: `function`. Such quoting would work
well for operator tokens too, and would stand out suitably in the source
code.</p>
<p>Another and possibly better idea is to provide
<code class="sourceCode cpp">ufcs_invoke</code> as a magic library
function which can take an object of <em>overload-set-type</em> and any
number of additional parameters and then check both for member and free
functions named as the function or operator specified when the
<em>overload-set-type</em> was deduced from said name.</p>
<p>Taken to the extreme this could always happen when deducing a
placeholder type from a function name. This means that to call a member
or free function begin you just write <code class="sourceCode cpp"><span class="kw">auto</span><span class="op">{</span>begin<span class="op">}(</span>object<span class="op">)</span></code>.
While weird this would be logical. This however breaks the rule that an
object of the <em>overload-set-type</em> shall behave exactly as using
the function name it was deduced from.</p>
<p>A really exotic idea would be to use <code class="sourceCode cpp"><span class="kw">operator</span> function_name</code> for
this purpose. This would work syntactically as the same name can not
refer to a type (as today) and a function at the same time in the same
scope. The problem is that this relies on the
<em>inconsistency</em> when deducing from operator tokens, which is
something we want to get rid of.</p>
<h1 data-number="5" id="implementation-experience"><span class="header-section-number">5</span> Implementation experience<a href="#implementation-experience" class="self-link"></a></h1>
<p>None so far.</p>
<h1 data-number="6" id="acknowledgements"><span class="header-section-number">6</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>Thanks to Jonas Persson for valuable insights regarding uniqueness of
the overload-set-types.</p>
<p>Thanks to Joe Gottman for feedback on P3183R0 which spurred adding
constructor and destructor support here.</p>
<p>Thanks to my employer, ContextVision AB for sponsoring my attendance
at C++ standardization meetings.</p>
<h1 data-number="7" id="bibliography"><span class="header-section-number">7</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="1" role="doc-bibliography">
<div id="ref-P2825R2" class="csl-entry" role="doc-biblioentry">
[P2825R2] Gašper Ažman. 2024-04-16. Overload Resolution hook:
declcall(unevaluated-postfix-expression). <a href="https://wg21.link/p2825r2"><div class="csl-block">https://wg21.link/p2825r2</div></a>
</div>
<div id="ref-P3183R0" class="csl-entry" role="doc-biblioentry">
[P3183R0] Bengt Gustafsson. 2024-04-15. Contract testing support. <a href="https://wg21.link/p3183r0"><div class="csl-block">https://wg21.link/p3183r0</div></a>
</div>
</div>
</div>
</div>
</body>
</html>
